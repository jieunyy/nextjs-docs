## Server Components

개발자는 서버 및 클라이언트 구성요소를 사용하여 
* 클라이언트 측 응용프로그램의 풍부한 상호 작용과 
* 기존 서버 렌더링의 향상된 성능을 결합하여
 
서버 및 클라이언트에 걸친 응용프로그램을 구축할 수 있다. <br/><br/><br/>


## Thinking in Server Components
React가 UI 구축에 대한 우리의 생각을 바꾼 것과 유사하게, 
React Server Components는 **서버와 클라이언트**를 활용하는 하이브리드 애플리케이션 구축을 위한 새로운 사고 모델을 도입한다.

**React**는 전체 응용프로그램 클라이언트 측(예: 단일 페이지 응용프로그램)을 렌더링하는 대신, 
**목적에 따라 구성요소를 렌더링할 위치를 유연하게 선택**할 수 있다. <br/><br/><br/>

## cf.Note) What is the main difference between Server Components and Client Components
서버 구성요소(Server Components)는 웹 애플리케이션의 UI(User Interface)를 구축하고 처리하는 작업을 서버 측에서 수행하는 반면, 클라이언트 구성요소(Client Components)는 클라이언트 측에서 UI를 생성하고 관리한다.
* 즉, 서버 구성요소는 주로 초기 로딩 시간을 최적화하고 서버의 부하를 줄이는 데 중점을 둔 반면, 클라이언트 구성요소는 애플리케이션의 인터랙티브한 부분과 동적인 UI 업데이트를 다루는 데 중점을 둔다.

서버 구성요소와 클라이언트 구성요소는 웹 애플리케이션의 다양한 측면을 다루기 위해 함께 사용될 수 있으며, 각각의 장점과 역할을 효과적으로 활용하는 것이 중요하다. <br/><br/><br/>

## Why Server Components?
서버 컴포넌트를 사용하여 개발자는 서버 인프라를 보다 효과적으로 활용할 수 있다.
서버 컴포넌트를 사용하면,
1. 초기 페이지 로드 속도가 빨라지고 
2. 클라이언트 측 JavaScript 번들 크기가 줄어든다. 
 * 이유1. **코드 분할(Code Splitting)**: 서버 구성요소는 클라이언트에게 필요한 JavaScript 코드를 동적으로 제공할 수 있다. 이를 통해 코드 분할을 수행하여, 클라이언트는 필요한 모듈만 요청하고 로드할 수 있다. 결과적으로, 클라이언트는 필요한 코드만 다운로드하므로 번들 크기가 줄어든다.
 * 이유2. **공통 종속성 제거(Common Dependency Removal)**: 서버 구성요소를 사용하면 클라이언트에 필요한 JavaScript 모듈 간에 공통된 종속성을 찾고, 이를 서버 측에서 처리할 수 있다. 그러면 클라이언트는 공통 종속성을 반복해서 다운로드하지 않아도 되므로 번들 크기가 줄어든다.
 * 이유3. **동적 로딩(Dynamic Loading)**: 서버 구성요소는 클라이언트에게 필요한 JavaScript 코드를 동적으로 로드할 수 있는 기능을 제공한다. 클라이언트는 필요한 코드가 있는 경우에만 해당 코드를 요청하고 로드할 수 있다. 이를 통해 필요한 코드만 다운로드하므로 번들 크기가 줄어든다.
 * 이유4. **압축과 최적화(Compression and Optimization)**: 서버 구성요소는 클라이언트에게 전달되는 JavaScript 번들을 압축하고 최적화할 수 있다. 이는 파일 크기를 줄이고 로딩 시간을 단축시키는 데 도움이 된다.
4. 클라이언트 측 런타임을 비동기식으로 로드하여 상호 작용을 추가할 수 있다. <br/><br/><br/>

## Client Components
클라이언트 컴포넌트를 사용하여 응용프로그램에 클라이언트 측 상호 작용을 추가할 수 있다. 
* Next.js에서는 서버에서 미리 렌더링되고 클라이언트에서 수화된다.

클라이언트 컴포넌트는 페이지 라우터의 구성요소가 항상 작동하는 방식으로 생각할 수 있다. <br/><br/><br/>

## The "use client" directive
(웹 애플리케이션의 코드 구조를 구분하고 이해하기 쉽게 만드는 데 사용: 개발자들 간의 코드 이해도를 높이고 협업을 용이하게 만들어줌)

**"use client"** 지시어는 서버와 클라이언트 구성요소 모듈 그래프 사이의 경계를 선언하는 규칙이다.
* "use client"는 서버 전용 코드와 클라이언트 코드 사이에 위치하며, 서버에서 클라이언트 부분까지의 경계를 통과하는 차단점을 정의하기 위해 가져오기 위의 파일 맨 위에 배치된다. 
* 파일에 "use client"가 정의되면 하위 구성요소를 포함하여 파일로 가져온 다른 모든 모듈이 클라이언트 번들의 일부로 간주된다.

서버 구성요소가 기본값이므로 "use client" 지시어로 시작하는 모듈에서 정의되거나 가져온 경우를 제외하고 모든 구성요소는 서버 구성요소 모듈 그래프의 일부이다. <br/><br/>
### Good to know: 
* 서버 구성요소 모듈 그래프의 구성요소는 서버에서만 렌더링된다.
* 클라이언트 구성요소 모듈 그래프의 구성요소는 주로 클라이언트에서 렌더링되지만 Next.js를 사용하면 서버에서 미리 렌더링하고 클라이언트에서 하이드레이팅할 수도 있다.
* 가져오기 전에 파일의 맨 위에 "use client" 지시사항을 정의해야 한다.
* 모든 파일에 "use client"를 정의할 필요는 없다. 클라이언트 모듈 경계는 "입구점"에서 한 번만 정의하면 클라이언트 모듈 경계로 가져온 모든 모듈이 클라이언트 구성요소로 간주된다. <br/><br/><br/>

## When to use Server and Client Components?
1. **Server Component**
* 데이터를 가져오는 경우
* 백엔드 리소스에 직접 액세스하는 경우
* 서버에 중요한 정보(액세스 토큰, API 키 등)를 유지하는 경우
* 서버에 대한 대규모 종속성 유지 / 클라이언트 측 JavaScript 줄이는 경우 <br/>

2. **Client Component**
* 대화형 및 이벤트 리스너를 추가(onClick(), onChange() 등)하는 경우
* State 및 수명 주기 효과를 사용(useState(), useReducer(), useEffect() 등)하는 경우
* 브라우저 전용 API를 사용하는 경우
* State, Effect 또는 브라우저 전용 API에 따라 사용자 지정 hook을 사용하는 경우 <br/><br/><br/>

## Patterns
### Moving Client Components to the Leaves
응용프로그램의 성능을 향상시키기 위해, 클라이언트 구성요소를 가능한 경우 구성요소 트리의 왼쪽으로 이동하는 것이 좋다.

* 일례로, 정적 요소(예: 로고, 링크 등)와 상태를 사용하는 대화형 검색 막대가 있는 레이아웃이 있을 수 있다.

전체 레이아웃을 클라이언트 구성요소로 만드는 대신 대화형 논리구조를 클라이언트 구성요소(예: <SearchBar />)로 이동하고 레이아웃을 서버 구성요소로 유지한다. 이것은 레이아웃의 모든 구성 요소 자바스크립트를 고객에게 보낼 필요가 없다는 것을 의미한다. <br/><br/><br/>

### Composing Client and Server Components
서버 및 클라이언트 구성요소는 동일한 구성요소 트리에서 결합할 수 있다.

React는 다음과 같은 렌더링 과정을 거친다:
서버에서 응답 결과를 클라이언트로 보내기 전에 모든 서버 구성요소를 렌더링한다.
* (여기에는 클라이언트 구성요소 내부에 중첩된 서버 구성요소가 포함된다. 이 단계에서 발견된 클라이언트 구성요소는 건너뛴다.)

클라이언트에서 React는 서버 구성요소의 렌더링된 결과에 클라이언트 구성요소 및 슬롯을 렌더링하여 서버와 클라이언트에서 수행된 작업을 병합한다.
서버 구성요소가 클라이언트 구성요소 내에 중첩되어 있는 경우, 렌더링된 내용은 클라이언트 구성요소 내에 올바르게 배치된다. <br/>
### Good to know: 
Next.js에서는 초기 페이지 로드 중에 위 단계의 서버 구성요소 및 클라이언트 구성요소의 렌더링 결과가 서버에서 HTML로 미리 렌더링된다. 이는 더 빠른 초기 페이지 로드를 생성하기 위함이다. <br/><br/><br/>

### Nesting Server Components inside Client Components
한편, 위에서 설명한 렌더링 흐름을 고려할 때, 서버 구성요소를 클라이언트 구성요소로 가져오는 데는 추가 서버 왕복이 필요하므로 제한이 있다. <br/><br/><br/>

### Recommended Pattern: Passing Server Components to Client Components as Props
따라서, 클라이언트 구성요소를 설계할 때 대응 특성을 사용하여 서버 구성요소의 "holes"을 표시할 수 있다. 즉, 일반적인 패턴은 React children 소품을 사용하여 "holes"을 만드는 것이다.<br/>
* 이때 서버 구성요소는 서버에서 렌더링되고 클라이언트 구성요소가 클라이언트에서 렌더링될 때 "hole"은 서버 구성요소의 렌더링된 결과로 채워진다. <br/>
* 한편, 일반 자식 프롭을 수락하도록 <ExampleClientComponent>를 리팩터링하고 <ExampleClientComponent>의 가져오기 및 명시적 중첩을 상위 구성 요소로 이동할 수 있다. <br/>
 
 ### Good to know: 
* 이 패턴은 children prop가 있는 레이아웃과 페이지에 이미 적용되어 있으므로 추가 래퍼 구성요소를 만들 필요가 없다.
* React components (JSX)을 다른 요소로 전달하는 것은 새로운 개념이 아니며 항상 반응 합성 모델의 일부였다.
* 이 구성 전략은 제안을 받는 구성요소가 prop이 무엇인지 알지 못하기 때문에, 서버 및 클라이언트 구성요소에서 작동한다.
이렇게 하면 클라이언트 구성요소가 클라이언트에서 렌더링되기 훨씬 전에 전달된 프롭을 서버에서 독립적으로 렌더링할 수 있다.
* 가져온 중첩 자식 구성 요소를 다시 렌더링하는 상위 구성 요소의 상태 변경을 방지하기 위해 "lifting content up"와 동일한 전략이 사용될 다. <br/><br/><br/>
 
 ## Passing props from Server to Client Components (Serialization/직렬화)
 서버에서 클라이언트 구성요소로 전달되는 속성은 직렬화되어야 한다. 즉, 함수, 날짜 등의 값을 클라이언트 구성요소에 직접 전달할 수 없다.<br/>
 **Where is the Network Boundary?**: 앱 라우터에서 네트워크 경계는 서버 구성요소와 클라이언트 구성요소 사이에 있다. getStaticProps/getServerSideProps와 페이지 구성요소 사이의 경계가 되는 페이지와는 다르다. 서버 구성요소 내부에서 가져온 데이터는 클라이언트 구성요소로 전달되지 않는 한 네트워크 경계를 통과하지 않으므로 직렬화할 필요가 없다. <br/><br/><br/>
 
## Keeping Server-Only Code out of Client Components (Poisoning)
 avaScript 모듈은 서버 및 클라이언트 구성요소 간에 공유될 수 있으므로 서버에서만 실행되도록 의도된 코드가 클라이언트로 몰래 유입될 수 있다. <br/>
### The "server only" package
 다른 개발자가 실수로 이러한 모듈 중 하나를 클라이언트 구성요소로 가져오는 경우, 의도하지 않은 클라이언트의 서버 코드 사용을 방지하기 위해 서버 전용 패키지를 사용하여 빌드 시간 오류를 발생시킬 수 있다.
* npm install server-only 후 import server-only code를 가진 파일에 'server-only';를 임포트한다. <br/><br/><br/>
 
## Data Fetching
