## Server Components

개발자는 서버 및 클라이언트 구성요소를 사용하여 
* 클라이언트 측 응용프로그램의 풍부한 상호 작용과 
* 기존 서버 렌더링의 향상된 성능을 결합하여
 
서버 및 클라이언트에 걸친 응용프로그램을 구축할 수 있다. <br/><br/><br/>


## Thinking in Server Components
React가 UI 구축에 대한 우리의 생각을 바꾼 것과 유사하게, 
React Server Components는 **서버와 클라이언트**를 활용하는 하이브리드 애플리케이션 구축을 위한 새로운 사고 모델을 도입한다.

**React**는 전체 응용프로그램 클라이언트 측(예: 단일 페이지 응용프로그램)을 렌더링하는 대신, 
**목적에 따라 구성요소를 렌더링할 위치를 유연하게 선택**할 수 있다. <br/><br/><br/>

## cf.Note) What is the main difference between Server Components and Client Components
서버 구성요소(Server Components)는 웹 애플리케이션의 UI(User Interface)를 구축하고 처리하는 작업을 서버 측에서 수행하는 반면, 클라이언트 구성요소(Client Components)는 클라이언트 측에서 UI를 생성하고 관리한다.
* 따라서 서버 구성요소는 주로 초기 로딩 시간을 최적화하고 서버의 부하를 줄이는 데 중점을 둔 반면, 클라이언트 구성요소는 애플리케이션의 인터랙티브한 부분과 동적인 UI 업데이트를 다루는 데 중점을 둔다.

서버 구성요소와 클라이언트 구성요소는 웹 애플리케이션의 다양한 측면을 다루기 위해 함께 사용될 수 있으며, 각각의 장점과 역할을 효과적으로 활용하는 것이 중요하다. <br/><br/><br/>

## Why Server Components?
서버 컴포넌트를 사용하여 개발자는 서버 인프라를 보다 효과적으로 활용할 수 있다.
서버 컴포넌트를 사용하면,
1. 초기 페이지 로드 속도가 빨라지고 
2. 클라이언트 측 JavaScript 번들 크기가 줄어든다. 
 * 이유1. **코드 분할(Code Splitting)**: 서버 구성요소는 클라이언트에게 필요한 JavaScript 코드를 동적으로 제공할 수 있다. 이를 통해 코드 분할을 수행하여, 클라이언트는 필요한 모듈만 요청하고 로드할 수 있다. 결과적으로, 클라이언트는 필요한 코드만 다운로드하므로 번들 크기가 줄어든다.
 * 이유2. **공통 종속성 제거(Common Dependency Removal)**: 서버 구성요소를 사용하면 클라이언트에 필요한 JavaScript 모듈 간에 공통된 종속성을 찾고, 이를 서버 측에서 처리할 수 있다. 그러면 클라이언트는 공통 종속성을 반복해서 다운로드하지 않아도 되므로 번들 크기가 줄어든다.
 * 이유3. **동적 로딩(Dynamic Loading)**: 서버 구성요소는 클라이언트에게 필요한 JavaScript 코드를 동적으로 로드할 수 있는 기능을 제공한다. 클라이언트는 필요한 코드가 있는 경우에만 해당 코드를 요청하고 로드할 수 있다. 이를 통해 필요한 코드만 다운로드하므로 번들 크기가 줄어든다.
 * 이유4. **압축과 최적화(Compression and Optimization)**: 서버 구성요소는 클라이언트에게 전달되는 JavaScript 번들을 압축하고 최적화할 수 있다. 이는 파일 크기를 줄이고 로딩 시간을 단축시키는 데 도움이 된다.
4. 클라이언트 측 런타임을 비동기식으로 로드하여 상호 작용을 추가할 수 있다. <br/><br/><br/>

## Client Components
클라이언트 컴포넌트를 사용하여 응용프로그램에 클라이언트 측 상호 작용을 추가할 수 있다. 
* Next.js에서는 서버에서 미리 렌더링되고 클라이언트에서 수화된다.

클라이언트 컴포넌트는 페이지 라우터의 구성요소가 항상 작동하는 방식으로 생각할 수 있다. <br/><br/><br/>

## The "use client" directive
(웹 애플리케이션의 코드 구조를 구분하고 이해하기 쉽게 만드는 데 사용: 개발자들 간의 코드 이해도를 높이고 협업을 용이하게 만들어줌)

**"use client"** 지시어는 서버와 클라이언트 구성요소 모듈 그래프 사이의 경계를 선언하는 규칙이다.
* "use client"는 서버 전용 코드와 클라이언트 코드 사이에 위치하며, 서버에서 클라이언트 부분까지의 경계를 통과하는 차단점을 정의하기 위해 가져오기 위의 파일 맨 위에 배치된다. 
* 파일에 "use client"가 정의되면 하위 구성요소를 포함하여 파일로 가져온 다른 모든 모듈이 클라이언트 번들의 일부로 간주된다.

서버 구성요소가 기본값이므로 "use client" 지시어로 시작하는 모듈에서 정의되거나 가져온 경우를 제외하고 모든 구성요소는 서버 구성요소 모듈 그래프의 일부이다. <br/><br/>
### Good to know: 
* 서버 구성요소 모듈 그래프의 구성요소는 서버에서만 렌더링된다.
* 클라이언트 구성요소 모듈 그래프의 구성요소는 주로 클라이언트에서 렌더링되지만 Next.js를 사용하면 서버에서 미리 렌더링하고 클라이언트에서 하이드레이팅할 수도 있다.
* 가져오기 전에 파일의 맨 위에 "use client" 지시사항을 정의해야 한다.
* 모든 파일에 "use client"를 정의할 필요는 없다. 클라이언트 모듈 경계는 "입구점"에서 한 번만 정의하면 클라이언트 모듈 경계로 가져온 모든 모듈이 클라이언트 구성요소로 간주된다. <br/><br/><br/>

## When to use Server and Client Components?
1. **Server Component**
* 데이터를 가져오는 경우
* 백엔드 리소스에 직접 액세스하는 경우
* 서버에 중요한 정보(액세스 토큰, API 키 등)를 유지하는 경우
* 서버에 대한 대규모 종속성 유지 / 클라이언트 측 JavaScript 줄이는 경우 <br/>

2. **Client Component**
* 대화형 및 이벤트 리스너를 추가(onClick(), onChange() 등)하는 경우
* State 및 수명 주기 효과를 사용(useState(), useReducer(), useEffect() 등)하는 경우
* 브라우저 전용 API를 사용하는 경우
* State, Effect 또는 브라우저 전용 API에 따라 사용자 지정 hook을 사용하는 경우 <br/><br/><br/>

## Patterns
### Moving Client Components to the Leaves
응용프로그램의 성능을 향상시키기 위해 클라이언트 구성요소를 가능한 경우 구성요소 트리의 왼쪽으로 이동하는 것이 좋다.

* 일례로, 정적 요소(예: 로고, 링크 등)와 상태를 사용하는 대화형 검색 막대가 있는 레이아웃이 있을 수 있다.

전체 레이아웃을 클라이언트 구성요소로 만드는 대신 대화형 논리구조를 클라이언트 구성요소(예: <SearchBar />)로 이동하고 레이아웃을 서버 구성요소로 유지한다. 이것은 레이아웃의 모든 구성 요소 자바스크립트를 고객에게 보낼 필요가 없다는 것을 의미한다.
